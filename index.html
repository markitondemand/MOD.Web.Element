<!DOCTYPE html>
<html>
<head>
	<title>GitHub - Markit On Demand - Element</title>
	<link rel="stylesheet" href="Content/css/bootstrap.css" />
	<link rel="stylesheet" href="Content/css/Style.css" />
</head>

<body>
	<header class="site affix navbar">
			<div class="container">
				<h1 class="navbar-brand">
					MOD.Web.Element
				</h1>
				<ul class="nav navbar-nav navbar-right">
					<li>
						<a href="https://github.com/markitondemand/MOD.Web.Element" title="MOD on GitHub" target="_blank">
							GitHub
						</a>
					</li>
					<li>
						<a href="http://www.markit.com/product/markit-on-demand" title="Markit On Demand" target="_blank">
							Markit On Demand
						</a>
					</li>
				</ul>
			</div>	
			<h2>
				<div class="container">
					An Object Oriented, MVC-friendly approach to rendering HTML in C#
				</div>
			</h2>
	</header>
	<div class="main">
		<div class="container">
			<div class ="row">
				<div class="col-sm-2">
					<nav class="navbar-scrollspy hidden-print affix" role="complementary">
						<ul class="nav section-nav">
							<li>
								<a href="#what">What</a>
							</li>
							<li>
								<a href="#why">Why</a>
							</li>
							<li>
								<a href="#where">Where</a>
							</li>
							<li>
								<a href="#how">How</a>
							</li>
							<li>
								<a href="#who">Who</a>
							</li>
							<li>
								<a href="#legal">Legal</a>
							</li>
						</ul>
					</nav>
				</div>
				<div class="col-sm-10">
					<section id="what">
						<h3>What</h3>
						<p>
							Element is a C# class library built for generating dynamic HTML. It is not a view engine or templating language, it uses normal C# syntax to create Elements, which can be manipulated by adding children and/ or setting/ modifying attributes. An <strong>Element</strong> can ultimately be "Rendered" and written out as a string (HTML). When building an HTML page with Element, the most common approach is to hold reference to a container element which may be the &lt;html&gt; node, the &lt;body&gt; node or a container node that is rendered and written to the page once content has been added to it.
						</p>
					</section>
					<section id="why">
						<h3>Why</h3>
						<p>
							There are a myriad of quality approaches to dynamically rendering HTML and all have their attributes. However, Element has some unique benefits that have held the test of time, traffic and hundreds of discerning web developers. Below, we'll outline several of those benefits. But first, a little history.
						</p>
						<p>
							The Element concept actually started as a JavaScript library. Before jQuery was cool, we wanted a convenient way to dynamically create and manipulate elements in the browser's DOM. document.createElement was clunky and we were doing quite a bit of on-the-fly element creation in JavaScript. Element.js was our solution to this problem - it allowed us to create nested element structures, apply class names, id's and other attributes, as well as event handlers in single statements. It was a hit.
						</p>
						<p>
							At this time, we were building most of our websites in ASP classic using JScript (don't hold it against us). As many of us were bemoaning the grim reality of "step-in, step-out" ASP code on very dynamic websites, a lightbulb went off. We could take the same concept and syntax from our JavaScript library and use it in our server-side code. In very little time we were hosting many of our high-profile, high-traffic web sites using the Element approach. Most of us that got in the swing of building sites this way never wanted to look back.
						</p>
						<p>
							Several years later, our team made a big transition away from ASP classic to .NET. After evaluating Web Forms and a few other approaches to rendering views, we again decided to carry the Element concept on to the next generation. While the syntax changed quite a bit from JavaScript to C#, the basic concept has stayed the same. So why do we like this paradigm so much? A few reasons are outlined below.
						</p>
						<h4>One Language to Code in</h4>
						<p>
							In building our HTML views with Element, we are actually just constructing C# classes. A class can correspond to an HTML document or a "module". We can also easily write simple methods that create Element structures for us. We do not have to jump in and out of HTML markup as we do in templates, nor do we have to learn new looping structures. To iteratively add child elements to a parent element, we can simply loop over a collection using a for loop within our C# code. Elements can be passed around and referenced throughout a program and can be programmatically manipulated prior to rendering.
						</p>
						<h4>Modular</h4>
						<p>
							Given that we are building our HTML views in C#, we can create "module" classes that behave like partial views, but allow endless flexibility. At it's simplest, a Module in this paradigm is nothing more than a class that has a container Element. When a module is added as a child to a parent Element, we just add the container Element to that parent. Of course, because our Module is just a C# class, we can leverage concepts like inheritance to increase consistency and reusability.
						</p>
						<h4>No Spaghetti Code</h4>
						<p>
							Stepping in and out of HTML to insert dynamic values inevitably gets messy. There are certainly steps we can take to reduce the mess, but highly dynamic, data-driven sites will become unwieldy in even the most skilled developers hands using a templating approach to rendering HTML. As we've noted, using the Element approach, we build our views entirely in C# so there is no stepping in and out. Conditionally adding class names to elements or looping through Model data structures becomes a much more graceful task.
						</p>
						<h4>Easy to Manipulate</h4>
						<p>
							Because Elements are objects rather than strings, we can easily do things like add classes to them, modify attributes or append children to them throughout our program. Similarly, we can pass references to these objects between classes as we need.
						</p>
						<h4>Inheritance in Views</h4>
						<p>Have modules that share a lot of similarities? Having trouble coding for these similarities in a reusable fashion? Because views (and partial views/ modules) are just C# classes, we can call on inheritance in the true OO sense. We can easily build an abstract base class that defines certain rendering methods, that several descendant classes can reference, increasing code reuse and improving maintainability.</p>
					</section>
					<section id="where">
						<h3>Where</h3>
						<div class="row">
							<div class="col-md-6">
								<h4>GitHub</h4>
								<a class="btn btn-primary" href="https://github.com/markitondemand/MOD.Web.Element">Download on GitHub</a>
							</div>
							<div class="col-md-6">
								<h4>NuGet</h4>
								<a class="btn btn-primary" href="https://www.nuget.org/packages/MOD.Web.Element">Download from Nuget</a>
							</div>
						</div>
					</section>
					<section id="how">
						<h3>How</h3>
						<p>Alright, we've heard enough talk about Element, lets see it in action! Below we'll go through some examples that show Element's syntax and some of its more powerful features in action.</p>
						<p>For a more in-depth example of Element in action, check out our <a href="https://github.com/markitondemand/ElementDemo" title="Demo Project" target="">Demo Project</a>.</p>
						<h4>Syntax</h4>
						<pre class="prettyprint">
// Create a div element
Element container = Element.Create("div");

// Create a div with a class name
Element container = Element.Create("div.container");

// Create a div with a class name and an id
Element container = Element.Create("div#myContainer.container");

// Create an element with some attributes
Element button = Element.Create("button", "button-name", "myButton", "button-value", "4");

// Add children to an element
button.Add(
    Element.Create("span").Add("My Button")
);

// Create more complex node structures in one statement
Element container = Element.Create("div.container").Add(
    Element.Create("ul").Add(
        Element.Create("li").Add("One"),
        Element.Create("li").Add("Two"),
        Element.Create("li").Add("Three")
    )
);

// Methods can return Elements
public static Element RenderButton(string buttonText)
{
    return Element.Create("button.btn").Add(
        Element.Create("span").Add(buttonText)
    );
}

// And we can modify those elements after the fact
Element button = MyClass.RenderButton("My Button");
if (conditional) 
{
    button.AddClass("super-button");
}
						</pre>
						<h5>Conditionals</h5>
						<p>Aside from using simple if statements to do things like add classes, we can incorporate logic within nested statements</p>
						<pre class="prettyprint">
// An example of adding  children conditionally
Element container = Element.Create("div.container").Add(
    Element.Create("h1").Add("Title"),
    conditional ? RenderContent() : RenderErrorContent(),
    Element.Create("div.footer").Add("Some footer content")
);

// If a null value is added to an element, it is ignored
Element container = Element.Create("div.container").Add(
    conditional ? RenderContent() : null
);
						</pre>
						<h5>Looping</h5>
						<pre class="prettyprint">
// Simple loop example
Element list = Element.Create("ul");

foreach (string name in names)
{
    list.Add(
        Element.Create("li").Add(name)
    );
}
						</pre>
						<h5>linq</h5>
						<p>We can take iteration to the next step by using linq statements in our Element statements</p>
						<pre class="prettyprint">
// Iteratively adding elements using linq
Element list = Element.Create("ul).Add(
    from item
    in items
    select Element.Create("li").Add(item.Name)
);
						</pre>
						<h4>Tips and Tricks</h4>
						<h5>Rendering an Element view in a Controller</h5>
						<p>Because we use Element with the .Net MVC framework, we need to be able to output actual HTML from our Controllers. Getting the HTML string from an Element is as simple as the following example:</p>
						<pre class="prettyprint">
Element myElement = Element.Create("html").Add(
    // Add the rest of your page content here
);
string html = myElement.Render().ToString();
						</pre>
						<p>In this scenario, we will also want to output the doctype before we write out HTML, so we can create the following helper method that internally calls System.Web.MVC.Controllers Content method:</p>
						<pre class="prettyprint">
public ActionResult Content(IRenderable m)
{
    string docType = @"<!DOCTYPE html>";
    Response.Write(docType);
    return Content(m.Render().ToString());
}
						</pre>
						<p>
							Finally, our controller actions will look something like the following:
						</p>
						<pre class="prettyprint">
public ActionResult Index()
{
    Element myElement = Element.Create("html").Add(
        // Add the rest of your page content here
    );
    return Content(myElement);
}
						</pre>
						<p>*note that Element structures generally should not be created within Controllers, the above is simply for the sake of example.</p>
					</section>
					<section id="who">
						<h3>Who</h3>
						<p>
							The <em>MOD</em> in <strong>MOD.Web.Element</strong> stands for Markit On Demand. Check our our <a href="http://www.markit.com/product/markit-on-demand">website</a> or our <a href="https://github.com/markitondemand">GitHub</a> page
							to learn more about what we are up to. If you are interested in career opportunites, please <a href="http://jobs.markitondemand.com/#careers">apply</a>.
						</p>
					</section>
					<section id="legal">
						<h3>Copyright and License</h3>
						<p>
							Copyright &copy; 2014 <a href="http://www.markit.com/product/markit-on-demand" title="Markit On Demand" target="_blank">Markit On Demand, Inc</a>. Element is licensed under the Apache License 2.0.
						</p>
					</section>
				</div>
			</div>
		</div>
	</div>
	<script src="Content/js/jquery-1.11.0.min.js"></script>
	<script src="Content/js/bootstrap.min.js"></script>
	<script>
		$(document.body).scrollspy({ target:".navbar-scrollspy", offset:162});
	</script>
	<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
</body>

</html>
